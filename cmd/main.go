package main

import (
	"fmt"
	"food-delivery/api/http"
	"food-delivery/internal/database"
	"food-delivery/pkg/logger"
	"github.com/gorilla/mux"
	"github.com/joho/godotenv"
	deflog "log"
	defhttp "net/http"
	"os"
)

func main() {

	// Загрузка переменных окружения из файла .env
	if err := godotenv.Load("F:\\food-delivery\\configs\\config.env"); err != nil {
		// В случае ошибки загрузки .env файла, завершаем программу с ошибкой
		deflog.Fatalf("ошибка загрузки .env файла: %s", err)
	}

	// Чтение пути к файлу логов и порта из переменных окружения
	logFilePath := os.Getenv("LOGFILE_PATH")
	port := os.Getenv("PORT")

	// Инициализация логгера
	log, err := logger.NewLogger(logFilePath)
	if err != nil {
		// В случае ошибки инициализации логгера, завершаем программу с ошибкой
		deflog.Fatalf(err.Error())
	}
	// Закрытие логгера при завершении работы программы
	defer log.Close()

	// Подключение к базе данных PostgreSQL
	db, err := database.ConnectPsql()
	if err != nil {
		// Логирование ошибки подключения к базе данных
		log.Error("", err)
		return
	}
	defer db.Close()
	log.Info("успешное подключение к PostgreSQL")

	// Подключение к Redis
	client, err := database.InitRedis()
	if err != nil {
		// Логирование ошибки подключения к Redis
		log.Error("ошибка подключения к бд:", err)
		return
	}
	defer client.Close()
	log.Info("успешное подключение к Redis")

	// Инициализация обработчиков
	authHandler := initAuthModule(db, client, log)
	//restaurantHandler := initRestaurantModule(db, client, log)

	// Инициализация маршрутизатора
	r := mux.NewRouter()

	// Инициализация маршрутов
	http.InitRoutes(r, authHandler)

	// Запуск HTTP-сервера
	err = defhttp.ListenAndServe(fmt.Sprintf(":%v", port), r)
	if err != nil {
		// Логирование ошибки запуска сервера
		log.Error("ошибка запуска сервера:", err)
		return
	}
	// Логирование успешного старта сервера
	log.Info("Сервер запушен на порту: " + port)
}

//TODO:
/*

	Админ может регистрировать пользователей с разными ролями:
	POST /api/admin/register-user — создание пользователя (только для админов)

	Админ может удалять пользователей из базы:
	DELETE /api/admin/delete-user/{id} — удаление пользователя (только для админов)

	Админ может изменять данные пользователя, включая роль:
	PUT /api/admin/update-user/{id} — обновление данных пользователя (только для админов)


	Создать middleware для проверки роли admin:
	1.Проверка JWT токена.
	2.Проверка, что роль пользователя — admin.

	Тестирование системы аутентификации:
	1.Тесты для регистрации.
	2.Тесты для входа.
	3.Тесты для выхода.
	4.Тесты для обновления токена.
	5.Тесты для админских операций.

	Реализация документации для эндпоинтов:
	1.Swagger для /auth:
		Эндпоинты регистрации, входа, выхода, обновления токена.
	2.Swagger для /admin/auth:
		Эндпоинты для создания, удаления и обновления пользователей.

	Подытожим:
	a.Реализация админских эндпоинтов для управления пользователями.
	b.Создание middleware для проверки роли админа.
	c.Тестирование системы аутентификации и админских операций.
	d.Документирование API с использованием Swagger.

*/

// написать тесты для сервиса auth (для регистрации и входа), поюзать mok-тесты...
// есть проблемка с подтверждение кода, если пользователь не успел подтвердить email (2 минуты есть на это), то ему придётся заного регестрироваться
// есть проблемка с записью данных в tokens с id, даже когда перезаписывается строка, id инкриментится

//

//TODO-ВЫПОЛНЕННЫЕ:
// полность написать логику auth (register, sing-in, sing-out, refresh .etc) ++
// отредактировать описание в README.md (переделать endpoint`s auth функционала) ++
// разобраться с расположением папок api слоя, потому-что нам надо будет в мейне запустить 1 функцию и инитить сразу все роуты ++
// также разобраться с инитом всех пакетов в internal слое потому-что нам также надо запустить 1 функцию и инитить сразу все слои в пакетах ++
// подключить подтверждение email при регистрации ++
// переписать схему проекта в README.md ++
// когда пользователь выходит из аккаунта, в базе active надо поменять на suspended, соответственно и наоборот ++
// при входе в аккаунт мы должны ещё проверять на то, что пользователь не blocked или не removed (в случае возвращаем опред. тип ошибки) ++
// надо создать таблицу с информацией активности аккаунтов (login_history), чтобы просмотривать когда и кто заходил на аккаунт ++
// создать таблицу в PostgreSQL (login_history) и протестировать работу ++
// Создать окончательные таблицы в PostgreSQL (users, tokens, login_history) и протестировать работу ++
//
//
